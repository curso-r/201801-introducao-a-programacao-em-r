<!DOCTYPE html>
<html>
  <head>
    <title>AULA 4: STRINGR/LUBRIDATE</title>
    <meta charset="utf-8">
    <meta name="author" content="Caio Lente + Curso-R" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# AULA 4: STRINGR/LUBRIDATE
## Ou ‚ÄòComo Complicar sua Vida em 2 Passos R√°pidos‚Äô
### Caio Lente + Curso-R

---




# √çndice

O que veremos hoje:

--

- Stringr

  - O que s√£o strings? üéª
  - Mexer com strings √© f√°cil üòÑ
  - Regex ü§¢
  - Mexer com strings √© d√≠f√≠cil üòû
  
--

- Lubridate
  - O que s√£o datas? üìÜ
  - Criando datas ü§ï
  - Mexer com datas √© f√°cil üòÑ
  - Mexer com datas √© dif√≠cil üòû



---

# Nossa motiva√ß√£o

"Por que vamos aprender a mexer com strings e datas?" e "Por que tem que ser com
esses pacotes dos quais eu nunca ouvi falar?"

Porque:

- Vari√°veis que trazem textos ou datas s√£o extremamente **importantes**
- Raramente encontramos tabelas que cont√©m somente n√∫meros e valores bin√°rios
- O R `base` tem fun√ß√µes muito ~~ruins~~ pouco consistentes para lidar com esses
tipos de dados
- Os pacotes `lubridate` e `stringr` s√£o excelentes op√ß√µes que j√° v√™m embutidas no
**tidyverse**
- Ambos foram idealizados por ~~um anjo que roubou meu cora√ß√£o~~ Hadley Wickham




---
background-image: url("https://images.unsplash.com/photo-1505218795627-2b9746a5343f?dpr=1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80&amp;cs=tinysrgb")
background-position: 50% 50%
class: center, middle, inverse

# STRINGR



---
class: inverse, center, middle

# O que s√£o strings?



---

# O b√°sico

Strings n√£o passam de sequ√™ncias de caracteres! Em portugu√™s o termo √© literalmente
traduzido como *cadeia de caracteres*.


```r
minha_primeira_string &lt;- "Eu adoro o IME!"
minha_primeira_string
```

```
#&gt; [1] "Eu adoro o IME!"
```

--

Strings aceitam praticamente qualquer coisa que est√° entre aspas, ent√£o podemos ir √†
loucura:


```r
minha_segunda_string &lt;- "„Åì„Çì„Å´„Å°„ÅØ! Est√° 40\u00BAC na l√° …ê…πo…ü"
minha_segunda_string
```

```
#&gt; [1] "„Åì„Çì„Å´„Å°„ÅØ! Est√° 40¬∫C na l√° …ê…πo…ü"
```

--

**EX:** Rode a fun√ß√£o `class()` em uma string. O que ela realmente √©?



---

# Escapando pela tangente

O que acontece se tentarmos colocar uma express√£o entre aspas dentro de uma
string?

```r
"Meu nome √© "Caio Lente""
```

--

O R n√£o nos permite fazer isso! Temos duas alternativas:

```r
"Meu nome √© 'Caio Lente'"
"Meu nome √© \"Caio Lente\""
```

--

A segunda estrat√©gia usa o que chamamos de *escaping*: um s√≠mbolo (`\`)
que indica que o pr√≥ximo caractere n√£o √© o que parece.


```r
cat("Meu nome √© \"Caio Lente\"")
```

```
#&gt; Meu nome √© "Caio Lente"
```

--

**EX:** Verifique as diferen√ßas entre o comportamento entre `print()` e `cat()`.



---

# Caracteres especiais

Usando a nossa nova ferramenta, podemos descrever uma infinitude de caracteres
n√£o tradicionais.


```r
cat("Uma lista feita √† m√£o:\n\t-Item 1;\n\t-Item dois.")
```

```
#&gt; Uma lista feita √† m√£o:
#&gt; 	-Item 1;
#&gt; 	-Item dois.
```

Os caracteres especiais `\n` e `\t` indicam respectivamente uma nova linha e
uma tabula√ß√£o.

--

Se n√£o pudermos usar caracteres n√£o-ASCII (como √© com o CRAN), podemos usar
a barra obl√≠qua aliada a c√≥digos Unicode para descrever qualquer caractere
imagin√°vel:


```r
"\u03b1\u03b2\u03b3"
```

```
#&gt; [1] "Œ±Œ≤Œ≥"
```



---

# Vetores de strings

Em outras linguagens (como C), strings s√£o vetores, o que quer dizer
que cada posi√ß√£o de uma string corresponde a um caractere! J√° no R,
`character` √© uma **classe at√¥mica** e ent√£o isso n√£o acontece.


```r
c("Um", "vetor", "de", "strings")[4]
```

```
#&gt; [1] "strings"
```

--

Isso pode ser um pouco dif√≠cil de entender se voc√™ j√° programou em
alguma linguagem diferente de R, mas n√£o demora pra pegar o jeito.

A √∫nica coisa com que precisamos tomar cuidado √© **fechar todas as aspas**!
Mesmo que estejamos em um vetor, deixar uma aspa aberta vai fazer o console
ficar esperando pelo final da string:

```r
&gt; c("Estou declarando", "um vetor", "de strings
+ 
+ 
+ SOCORRO!
```



---

# At√© agora

- `character` (genericamente conhecido como "string") √© um tipo de dado que
serve para amazenar textos
- Podemos incluir praticamente qualquer coisa em uma string
- Usando a barra obl√≠qua para a esquerda, espapamos o caractere que a segue
- Podemos criar vetores de strings como com qualquer outro tipo de dado

--

### Exerc√≠cio

Crie um vetor que carrega dois pequenos textos. Cada texto deve ter dois par√°grafos
cada e cada par√°grafo deve ter pelo menos 3 linhas. Cada par√°grafo deve come√ßar
com uma tabula√ß√£o e nenhuma linha pode passar de 80 caracteres. Pelo menos um dos
textos deve ter uma cita√ß√£o.

**Dicas:** Para saber quantos caracteres tem cada linha, use o contador na esquerda
inferior do RStudio. Escreva cada linha separadamente e depois junte-as com caracteres
especiais.d



---
class: inverse, center, middle

# Mexer com strings √© f√°cil



---

# O pacote stringr

Todas as fun√ß√µes do `stringr` come√ßam com o prefixo `str_`. Isso facilita muito
quando precisamos buscar buscar alguma coisa no nosso environment!


```r
library(stringr)
```

--

**EX:** Carregue o `stringr` e procure por suas fun√ß√µes usando a tecla TAB.

--

A fun√ß√£o mais b√°sica do pacote √© `str_length()`, que retorna o n√∫mero de caracteres
em uma string. Como todas as fun√ß√µes do `stringr` s√£o vetorizadas, o primeiro
argumento delas pode ter tanto uma √∫nica string quando um vetor de strings.


```r
str_length(c("Um", "Dois", "Tr√™s ", "Quatro", "Cinco"))
```

```
#&gt; [1] 2 4 5 6 5
```

--

**EX:** Verifique como s√£o contados caracteres escapados.



---

# As maravilhas da formata√ß√£o

Uma das tarefas mais comuns que precisamos executar quando se trata de strings
√© transformar um texto de formata√ß√£o duvidosa em um texto com a formata√ß√£o que
desejamos:


```r
s &lt;- "nAh uNIaUM xOvIeHtIkA, U MiGuXeixxXXxx ixXxKreVi vC"
str_to_lower(s)
```

```
#&gt; [1] "nah uniaum xoviehtika, u miguxeixxxxxx ixxxkrevi vc"
```

```r
str_to_upper(s)
```

```
#&gt; [1] "NAH UNIAUM XOVIEHTIKA, U MIGUXEIXXXXXX IXXXKREVI VC"
```

```r
str_to_title(s)
```

```
#&gt; [1] "Nah Uniaum Xoviehtika, U Miguxeixxxxxx Ixxxkrevi Vc"
```

Agora o texto est√° muito mais compreens√≠vel!



---

# Tirando peda√ßos

Outra utilidade importante √© retirar fatias indesejadas de strings. Se tivermos
um texto com espa√ßos extras no in√≠cio e no final, podemos recorrer √† fun√ß√£o
`str_trim()`:


```r
str_trim(c("M", "F", "F", " M", " F ", "M"))
```

```
#&gt; [1] "M" "F" "F" "M" "F" "M"
```

--

**EX:** Tabula√ß√µes s√£o consideradas espa√ßos?

--

J√° a fun√ß√£o `str_sub()` usa as posi√ß√µes dos caracteres nas strings para determinar
o que remover:


```r
str_sub(c("__SP__", "__MG__", "__RJ__"), start = 3, end = 4)
```

```
#&gt; [1] "SP" "MG" "RJ"
```

--

**EX:** Teste `str_sub()` dando valor s√≥ para `start` ou s√≥ para `end`. O que
acontece se passarmos n√∫meros negativos para ambos os par√¢metros?



---

# Concatena√ß√£o

Assim como temos `length()` e `str_length()`, temos `c()` e `str_c()`:


```r
str_c("O valor p √©: ", "0.03")
```

```
#&gt; [1] "O valor p √©: 0.03"
```

--

**EX:** E se pass√°ssemos uma vari√°vel num√©rica para essa fun√ß√£o?

--

Vetoriza√ß√£o tamb√©m n√£o √© um problema para a `str_c()`:


```r
s1 &lt;- c("O R", "O Java")
s2 &lt;- c("bom", "ruim")
str_c(s1, " √© muito ", s2)
```

```
#&gt; [1] "O R √© muito bom"     "O Java √© muito ruim"
```

--

**EX:** Use o argumento `sep` para remover a repeti√ß√£o de espa√ßos. Use o argumento
`collapse` para juntar as duas frases em uma.



---

# At√© agora

- Com `str_length()` podemos contar quantos caracteres tem uma string
- Com `str_to_*()` podemos formatar uma string facilmente
- Com `str_trim()` e `str_sub()` podemos retirar peda√ßos de strings
- Com `str_c()` podemos concatenar strings

--

### Exerc√≠cio

Partindo do vetor de strigs `vs`, obtenha o texto `s`:

```r
vs &lt;- c("***O n√∫mero   " , "de caRACTeres", "   nEste TexTO", "√©")
s &lt;- "o n√∫mero de caracteres neste texto √© 36"
```

**Dicas:** Use pipes (voc√™ s√≥ precisar√° de uma pipeline) e lembre-se do
*placeholder*. Para saber se ambos os textos obtidos s√£o iguais, use o
operador de igualdade (`=`) normalmente.

???

vs %&gt;%
  str_trim() %&gt;%
  str_c(collapse = " ") %&gt;%
  str_to_lower() %&gt;%
  str_sub(start = 4) %&gt;%
  str_c(str_length(.), sep = " ")



---
class: inverse, center, middle

# Regex



---

# Express√µes regulares

*Regular expressions* ou somente "regex" s√£o uma ferramenta que usamos para
capturar padr√µes em strings. Veja um pequeno exemplo com a fun√ß√£o `str_detect()`
(que detecta se uma determinada string apresenta um certo padr√£o):


```r
str_detect(c("banana", "BANANA", "maca", "nona"), pattern = "na")
```

```
#&gt; [1]  TRUE FALSE FALSE  TRUE
```

--

Alguns caracteres tem significados especiais dentro de express√µes regulares
para que possamos fazer casamentos (*matchings*) mais interessantes.

Os caracteres `.`, `^` e `$` casam respectivamente com qualquer caractere,
o in√≠cio de uma string e o final de uma string.

--

**EX:** Mude o valor do argumento `pattern` no c√≥digo acima para que a
express√£o d√™ match com qualquer string que tenha como segunda letra um
`a` min√∫sculo.



---

# Caracteres especiais (o retorno)

Mas o que acontece se quisermos dar match em um ponto? Ou em um cifr√£o? Assim
como fizemos na primeira parte da aula, usando a `\` podemos escapar um caractere
tamb√©m em regex!

Mas tem um problema... Se usarmos `\.` para tentar dar match em um ponto, o R vai
escapar a barra e assim obter somente um ponto (conclu√≠ndo erroneamente que falta
alguma coisa no padr√£o). Precisamos ent√£o escapar **duas vezes**!


```r
str_detect(c("ba.ana", "BANA.A", "ma.a", "n.na"), pattern = "a\\.a")
```

```
#&gt; [1]  TRUE FALSE  TRUE FALSE
```

--

**EX:** Como far√≠amos para dar match em um padr√£o j√° escapado (como "\\\\.")?
D√™ match em um caractere de nova linha e em um caractere de tabula√ß√£o.

--

**REGRA GERAL**: Quando em d√∫vida, divida ou multiplique o n√∫mero de barras por
2... N√£o √© elegante, mas com o tempo voc√™ vai pegando o jeito.



---

# Quantos e quais

Outra funcionalidade interessante do regex √© a possibilidade de passar um n√∫mero de
vezes para um padr√£o se repetir. `+` indica que um padr√£o se repete uma ou mais vezes,
`*` indica que um padr√£o se repete zero ou mais vezes, e `{m,n}` indica que um padr√£o
se repete entre `m` e `n` vezes (varia√ß√µes importantes s√£o `{m}`, `{,n}` e `{m,}`).


```r
str_detect(c("oi", "oii", "oiii", "oiiii"), pattern = "oi{3,}e*")
```

```
#&gt; [1] FALSE FALSE  TRUE  TRUE
```

--

Tamb√©m importante s√£o os marcadores de conjuntos. Tudo que estiver dentro de um `()`
vai ser tratado como uma unidade indivis√≠vel; j√° colocando caracteres dentro de
um `[]`, casamos com qualquer um deles.


```r
str_detect(c("banana", "baNANA", "BAnana"), ".[Aa](na){2}")
```

```
#&gt; [1]  TRUE FALSE  TRUE
```



---

# Miscel√¢nea

Alguns outros padr√µes de regex que podem se fazer √∫teis:

- `[a-z]`, `[A-Z]` e `[0-9]` casam com letras min√∫sculas, letras mai√∫sculas e
n√∫meros (√© poss√≠vel us√°-los juntos)
- `[^abc]` casa com qualquer coisa **menos** `a`, `b` e `c`
- `a?` casa com 0 ou 1 `a`


```r
str_detect(c("ba ana", "BANANA", "maca", "nona"), "[^Bn]a ?[ca]")
```

```
#&gt; [1]  TRUE FALSE  TRUE FALSE
```

--

Se voc√™ estiver se sentindo um pouco perdido, n√£o se preocupe: regex n√£o √© um
assunto simples. N√£o fique com medo de consultar tutoriais ou *cheat sheets*
na hora que bater uma d√∫vida!

O melhor recurso ao qual temos acesso quando programando em R √© o comando a
seguir, que mostra todos os padr√µes que o `stringr` aceita:

```r
?stringi::stringi-search-regex
```



---

# At√© agora

- Regex √© uma ferramenta que nos permite detectar padr√µes em strings
- Caracteres como `.`, `^` e `$` casam em situa√ß√µes especiais
- Quantificadores como `?`, `+`, `*` e `{m,n}` determinam quantas vezes um
padr√£o casa
- `[]` e `()` determinam conjuntos de padr√µes

--

### Exerc√≠cio

Dado o corpus presente em `stringr::words`, crie express√µes regulares que casem
com as palavras que:

- Come√ßam com 3 consoantes
- T√™m 3 ou mais vogais em sequ√™ncia
- T√™m duas ou mais ocorr√™ncias onde uma vogal precede uma consoante

**Dica:** Usem `str_view()` com `match = TRUE` para ver todas as palavras
retornadas pelo matching.



---
class: inverse, center, middle

# Mexer com strings √© d√≠f√≠cil



---

# N√£o entre em p√¢nico

Essa se√ß√£o tem "dif√≠cil" no nome, mas ela n√£o √© t√£o dif√≠cil assim. N√£o vou ensinar
praticamente nenhum outro comando de regex, mas aqui voc√™ vai precisar entender
como o regex se encaixa com as fun√ß√µes mais importantes do stringr.

Tamb√©m n√£o perca de vista que, apesar de os exemplos at√© agora terem sido em vetores
de strings, na vida real voc√™ proavavelmente estaria aplicando essas fun√ß√µes nas
colunas de uma tabela.

--

E se voc√™ precisar de um incentivo...



---
class: center, middle

![](https://media.giphy.com/media/100QWMdxQJzQC4/giphy.gif)



---

# Substitui√ß√£o

Uma das tarefas mais comuns no tratamento de strings √© a substitui√ß√£o de um padr√£o
por outro. Para isso temos as fun√ß√µes `str_replace()` e `str_replace_all()` que
substituem, respectivamente, o primeiro ou todos os padr√µes encontrados.


```r
str_replace("banana", pattern = "na", replacement = "XX")
```

```
#&gt; [1] "baXXna"
```

--

Uma funcionalidade destas (e outras) fun√ß√µes √© a possibilidade de usar o padr√£o
procurado na substitui√ß√£o usando refer√™ncias. Simplesmente use padr√µes da forma
`\\N` no `replacement` onde `N` √© o √≠ndice de um `()`:


```r
str_replace_all("banana", pattern = "(na)", replacement = "XX\\1")
```

```
#&gt; [1] "baXXnaXXna"
```

--

**EX:** Dado um n√∫mero de 11 d√≠gitos, transforme-o em um CPF da forma `544.916.518-84`.



---

# Extra√ß√£o

Com `str_extract()` e `str_extract_all()`, extra√≠mos padr√µes de strings. Podemos
usar isso para tirar de uma string apenas a parte de casa com um padr√£o:


```r
pessoas &lt;- c("Jo√£o Silva", "Joana Lima", "Madonna")
str_extract(pessoas, pattern = "[:alpha:]+$")
```

```
#&gt; [1] "Silva"   "Lima"    "Madonna"
```


```r
str_extract_all(pessoas, pattern = "[A-Z]")
```

```
#&gt; [[1]]
#&gt; [1] "J" "S"
#&gt; 
#&gt; [[2]]
#&gt; [1] "J" "L"
#&gt; 
#&gt; [[3]]
#&gt; [1] "M"
```



---

# Matching

Com `str_match()` e `str_match_all()` conseguimos quebrar strings em matrizes
onde cada coluna √© uma parte do match. No caso abaixo, a primeira coluna √© o
match todo, a segunda √© o primeiro `()` e a terceira √© o segundo `()`.


```r
pessoas &lt;- c("Silva, Jo√£o", "Lima, Joana", "Madonna")
str_match(pessoas, pattern = "(.*), ([:alpha:]+)")
```

```
#&gt;      [,1]          [,2]    [,3]   
#&gt; [1,] "Silva, Jo√£o" "Silva" "Jo√£o" 
#&gt; [2,] "Lima, Joana" "Lima"  "Joana"
#&gt; [3,] NA            NA      NA
```

--

No c√≥digo acima, `:alpha:` representa o conjunto dos caracteres alfab√©ticos
(tanto com quanto sem acento). Isso resolve o problema no qual `[a-zA-Z]`
n√£o casaria com `Jo√£o`.

--

**EX:** O que acontece quando quebramos as strings do vetor `pessoas` em
todas as letras (usando `str_match_all()`)?



---

# Quebra

Se quisermos quebrar uma string em certos pontos podemos usar `str_split()`.
Essa fun√ß√£o usa um padr√£o e divide uma string em um vetor de strings
quebrando-a exatamente onde encontrar o padr√£o.


```r
str_split("Voc√™ quer um vetor @?", pattern = " ")
```

```
#&gt; [[1]]
#&gt; [1] "Voc√™"  "quer"  "um"    "vetor" "@?"
```

--

Atrav√©s de `str_split_fixed()` podemos limitar o n√∫mero m√°ximo de quebras
(mas a√≠ voltamos a obter uma tabela):


```r
str_split_fixed("Voc√™ quer um vetor @?", pattern = " ", n = 3)
```

```
#&gt;      [,1]   [,2]   [,3]         
#&gt; [1,] "Voc√™" "quer" "um vetor @?"
```



---

# At√© agora

- Para substituir um padr√£o por um texto, podemos usar `str_replace()`
- Para extrar um padr√£o de uma string, podemos usar `str_extract()`
- Para casar um padr√£o com um texto, podemos usar `str_match()`
- Para quebrar uma string onde ocorre um padr√£o, podemos usar `str_split()`

--

### Exerc√≠cio

Partindo de `stringr::sentences`, crie o vetor `no_the`, onde todas as
ocorr√™ncias da palavra "the" (ou "The") s√£o removidas (mas tendo em mente que
as frases devem continuar come√ßando com letra mai√∫scula)

**Dica:** Tente criar uma tabela com `stringr::sentences` para poder operar
em colunas usando `dplyr::mutate()`. √â poss√≠vel resolver esse problema com
apenas uma pipeline.

???

ss %&gt;%
  str_replace_all("[Tt]he ?", "") %&gt;%
  dplyr::tibble(sentence = .) %&gt;%
  dplyr::mutate(
    first = str_extract(sentence, "^[:alpha:]"),
    first = str_to_upper(first),
    sentence = str_replace(sentence, "^[:alpha:]", first)) %&gt;%
  dplyr::pull(sentence)



---
background-image: url("https://images.unsplash.com/photo-1435527173128-983b87201f4d?dpr=1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80&amp;cs=tinysrgb")
background-position: 50% 50%
class: center, middle, inverse

# LUBRIDATE



---
class: inverse, center, middle

# O que s√£o datas?



---

# O b√°sico

Quando tratamos de datas e hor√°rios em liguagens de programa√ß√£o, geralmente
estamos falando sobre um **n√∫mero** que ser√° expresso como uma **string**.


```r
library(lubridate)
now()
```

```
#&gt; [1] "2018-01-21 19:08:56 -02"
```

--

Acima vemos que `now()` retorna o *datetime* (data-hora) atual*, incluindo o
fuso hor√°rio no qual estamos. Mas se convertermos essa pseudo-string para
`integer`, vemos que o n√∫mero retornado n√£o faz muito sentido...


```r
as.integer(now())
```

```
#&gt; [1] 1516568936
```

.footnote[[*] Ele era atual quando eu fiz os slies...]



---

# Unix time

*Unix time* √© a forma como todos os aparelhos eletr√¥nicos modernos sabem que horas
s√£o. O n√∫mero enorme que vimos no slide anterior represente quantos **segundos**
se passaram desde o in√≠cio do dia 01/01/1970.


```r
as.integer(as_datetime("1970-01-01 00:00:00"))
```

```
#&gt; [1] 0
```

--

**EX:** O que acontece quando convertemos uma data-hora anterior a 1970?

--

Agora que voc√™ sabe como datas e horas s√£o armazenadas, j√° √© poss√≠vel deduzir por
que esse √© um tipo de dado problem√°tico: n√≥s pensamos em datas como um texto mas
na verdade estamos trabalhando com um n√∫mero!


```r
now() + 2592000
```

```
#&gt; [1] "2018-02-20 18:08:56 -03"
```

--

**EX:** O que de interessante aconteceu quando adicionamos 1 m√™s a `now()`?



---

# ISO 8601

Como voc√™ j√° deve ter notado, todas as fun√ß√µes at√© agora retornavam as datas e
hor√°rios na forma `AAAA-MM-DD HH:MM:SS`. Isso n√£o √© √† toa! Este formato √©...

&gt; ... definido pela *Organiza√ß√£o Internacional para Padroniza√ß√£o* no padr√£o
"ISO 8601" que define "elementos de dados e formatos de interc√¢mbio para
representa√ß√£o e manipula√ß√£o de datas e horas‚Äù.

--

Desta forma, todos os outros formatos (inclusive o que usamos no dia-a-dia)
precisa ser convertido antes de poder ser interpretado pelos aparelhos eletr√¥nicos.


```r
as_date("20/01/2018")
```

```
#&gt; [1] NA
```

--

Agora j√° temos todos os ingredientes para um problem√£o... Datas e horas s√£o escritos
como strings, mas representados internamente como n√∫meros e existe um padr√£o
internacional para escrever datas, mas nenhum pa√≠s o usa.



---

# At√© agora

- Existem dois tipos principais para trabalhar com datas e hor√°rios: `date` e
`datetime`
- Com `today()` e `now()` podemos obter informa√ß√µes sobre a data-hora atual
(incluindo fuso hor√°rio)
- Com `as_date()` e `as_datetime()` conseguimos converter uma data ou data-hora
no padr√£o ISO 8601 para o formato compreendido pelo R

--

### Exerc√≠cio

Analise 3 conjuntos de fun√ß√µes: `as_date()` e `as_datetime()`, `make_date()` e
`make_datetime()`, `date()`. O que diferencia esses grupos de fun√ß√µes? Por que
n√£o existe uma fun√ß√£o `datime()`?

**Dica:** Para ler a documenta√ß√£o de uma fun√ß√£o, execute um comando da forma
`?nome_da_funcao`. N√£o se preocupe com os conceitos que voc√™ ainda n√£o viu,
voc√™ n√£o precisa deles para entender essas fun√ß√µes.



---
class: inverse, center, middle

# Criando datas



---

# Com datas bem formatadas

O jeito mais simples de criar uma data ou uma data-hora √© com as primeiras
fun√ß√µes que vimos: `as_date()` e `as_datetime()`. Para que elas funcionem,
a entrada precisa estar praticamente 100% formatada no ISO 8601.


```r
as_datetime("2018-01-20 00:02:05")
```

```
#&gt; [1] "2018-01-20 00:02:05 UTC"
```

--

**EX:** Passe uma data para `as_datetime()` e uma data-hora para `as_date()`.

--

Como tamb√©m vimos na se√ß√£o anterior, outro jeito de criar datas √© passando
seus componentes individuais para `make_date()` e `make_datetime()`. Este m√©todo
√© particularmente √∫til quando tratando tabelas!


```r
make_date(2018, 01, 20)
```

```
#&gt; [1] "2018-01-20"
```



---

# Fugindo do ISO 8601

Se quisermos criar uma data (sem hor√°rio), podemos usar a fam√≠lia `dmy()`, `ymd()`,
`mdy()` e assim por diante... Elas procuram os campos (*day*, *month* e *year*) na
ordem em que a respectiva letra aparece no nome da fun√ß√£o.


```r
dmy("20/01/2018")
```

```
#&gt; [1] "2018-01-20"
```

--

**EX:** O que acontece se passarmos o n√∫mero `20012018` para a fun√ß√£o acima?

--

Para data-horas, a l√≥gica √© a mesma: `dmy_hms()`, `ymd_hms()`, etc. Agora as letras
depois do sublinhado representam *hour*, *minute* e *second*.


```r
dmy_hms("20/01/2018 12:02:50")
```

```
#&gt; [1] "2018-01-20 12:02:50 UTC"
```

--

**EX:** E se n√£o quisermos especificar os minutos ou segundos de um datetime?



---

# Fusos hor√°rios

Um componente importante de datetimes que ainda n√£o abordamos diretamente s√£o
os fusos hor√°rios. Praticamente todas as fun√ß√µes de cria√ß√£o de datas t√™m um
argumento `tz` que nos permite especificar o fuso.


```r
t1 &lt;- dmy_hms("01/06/2015 12:00:00", tz = "America/New_York")
t2 &lt;- dmy_hms("01/06/2015 13:00:00", tz = "America/Sao_Paulo")
t1 == t2
```

```
#&gt; [1] TRUE
```

--

**EX:** Crie um vetor `c(t1, t2)`. O que acontece quando voc√™ o imprime?

--

Para trocar o fuso de um datetime, basta usar `with_tz()`:


```r
with_tz(t1, tzone = "Australia/Lord_Howe")
```

```
#&gt; [1] "2015-06-02 02:30:00 +1030"
```

--

**EX:** D√™ uma olhada na lista de fusos presentes em `OlsonNames()`.



---

# At√© agora

- Com `as_date()` e `as_datetime()` podemos criar datas a partir do ISO 8601
- Com `make_*()` podemos criar datas a partir de seus componentes
- Com as fam√≠lias `ymd()` e `ymd_hms()` podemos criar datas a partir de qualquer
formato
- Podemos atribuir fusos a data-horas com o argumento `tz`

--

### Exerc√≠cio

Partindo do vetor de strigs `vt`, obtenha a data-hora `t`. Voc√™ deve fazer isso
de duas formas diferentes: uma deve usar somente o pacote `lubridate` e a outra
deve usar o pacote `stringr` tamb√©m.


```r
vt &lt;- c("2015", "31", "03", "02", "59")
t &lt;- ymd_hm("2015-03-31 02:59")
```



---
class: inverse, center, middle

# Mexer com datas √© f√°cil



---

# Componentes

Depois que aprendemos a construir datas, entender seus componentes √© uma tareafa
razoavelmente simples. Usando os nomes em ingl√™s das diferentes unidades de medida
de uma data-hora, podemos extrair cada unidade separadamente.


```r
dt &lt;- ymd_hms("2016-07-08 12:34:56")
c(year(dt), month(dt), day(dt), hour(dt), minute(dt), second(dt))
```

```
#&gt; [1] 2016    7    8   12   34   56
```

--

Al√©m destas fun√ß√µes b√°sicas, tamb√©m temos acesso a algumas varia√ß√µes. `yday()` nos
d√° o dia do ano, enquanto `wday()` nos d√° o dia da semana (1 = domingo e 7 = s√°bado).


```r
c(yday(dt), wday(dt))
```

```
#&gt; [1] 190   6
```

--

**EX:** Para que servem os argumentos de `wday()`?



---

# Componentes (cont.)

Uma propriedade interessante dos componentes √© que podemos atribuir valores
diretamente a eles. Basta usar o operador de atribui√ß√£o (`&lt;-`) na sele√ß√£o de
um componente:


```r
year(dt) &lt;- 2020
dt
```

```
#&gt; [1] "2020-07-08 12:34:56 UTC"
```

--

**EX:** Tente atribuir um valor inv√°lido (maior que `31`) para `day(dt)`

--

Tamb√©m √© poss√≠vel arredondar uma data-hora para o componente mais pr√≥ximo: use
`roud_date()` e passe o nome de um componente para o argumento `unit`. Se voc√™
precisar dos operadores de teto e ch√£o, eles tamb√©m est√£o dispon√≠veis
(`floor_date()` e `ceiling_date()`).


```r
round_date(dt, "day")
```

```
#&gt; [1] "2020-07-09 UTC"
```



---
class: inverse, center, middle

# Mexer com datas √© dif√≠cil



---

# Talvez entre em p√¢nico

Como voc√™ deve ter notado, a se√ß√£o passada foi bastante curta e nem teve uma
recapitula√ß√£o... Foi esse o caso porque a utilidade real do pacote lubridate
n√£o est√° em extrair os componentes das data-horas (apesar de as vezes isso vir
a calhar).

O que veremos nesta se√ß√£o √© a real vantagem do pacote, mas infelizmente n√£o √© um
assunto t√£o simples, ent√£o pode ser que voc√™ fique meio perdido. Isso √© normal
e demora um bom tempo at√© que as coisas comecem a fazer sentido.

--

E se voc√™ precisar de um incentivo...



---
class: center, middle

![](https://media.giphy.com/media/bkKvvzE9PEcTK/giphy.gif)



---

# Dura√ß√µes

No R tradicional, mexer com a diferen√ßa entre dois objetos data-hora pode ser
algo muito complicado e de comportamento imprevis√≠vel, mas o `lubridate` nos
fornece uma interface consistente com `duration` que sempre retorna a dura√ß√£o
em segundos.


```r
as.duration(today() - dmy("28/12/1995"))
```

```
#&gt; [1] "696384000s (~22.07 years)"
```

--

Se quisermos construir uma dura√ß√£o, basta utilizar as fun√ß√µes de componente que
j√° aprendemos no plural e com um `d` na frente:


```r
dyears(1) + dweeks(12) + dhours(15)
```

```
#&gt; [1] "38847600s (~1.23 years)"
```

--

**EX:** Encontre a data de amanh√£ usando `today()` e um construtor de dura√ß√£o.



---

# Per√≠odos

Como nem sempre queremos diferen√ßas de tempo e aritm√©tica com datas resumidas a
uma dura√ß√£o em segundos, o `lubridate` nos fornece o conceito de `periods`
(dura√ß√µes que s√£o leg√≠veis para um humano). Seus contrutures s√£o os componentes
no plural:


```r
years(1) + weeks(12) + hours(15)
```

```
#&gt; [1] "1y 0m 84d 15H 0M 0S"
```

--

A maior diferen√ßa entre dura√ß√µes e per√≠odos aparece quando lidamos com as varia√ß√µes
naturais no comprimento das unidades temporais. Veja por exemplo o que acontece quando
adicionamos `dyears(1)` e `years(1)` a um ano bissexto:


```r
c(ymd("2016-01-01") + dyears(1), ymd("2016-01-01") + years(1))
```

```
#&gt; [1] "2016-12-31" "2017-01-01"
```

--

**EX:** Onde mais esse tipo de diferen√ßa poderia aparecer?

???

Mudan√ßa no hor√°rio de ver√£o



---

# Intervalos

Para complicar ainda mais o que acabamos de ver, imagine que precisamos
determinar quantos dias cabem em um m√™s. Isso naturalmente depende porque
tem todo m√™s tem o mesmo n√∫mero de dias...


```r
months(1) / days(1)
```

```
#&gt; estimate only: convert to intervals for accuracy
```

```
#&gt; [1] 30.4375
```

--

Para isso temos o conceito de `interval`, uma dura√ß√£o com um ponto de in√≠cio.
Usando o operador infixo `%--%`, determinamos um intervalo e assim fica f√°cil
de obter um resultado preciso:


```r
(today() %--% (today() + months(1))) / days(1)
```

```
#&gt; [1] 31
```

--

**EX:** `(today() %--% (today() + years(1))) / months(1)` funciona?



---

# At√© agora

- Usando componentes (`day()`, `month()`, `year()`, etc.) podemos trabalhar com
as partes de uma data-hora
- Com dura√ß√µes podemos realizar opera√ß√µes com diferen√ßas de tempo
- Com per√≠odos temos acesso a dura√ß√µes em uma forma mais leg√≠vel e interpret√°vel
- Com intervalos podemos dar um ponto inicial a uma opera√ß√£o temporal

--

### Exerc√≠cio

Partindo de `lubridate::lakers`, determine, em m√©dia, quanto tempo o Lakers
(`team == "LAL"`) demora para arremessar a primeira bola (`etype == "shot"`)
no primeiro per√≠odo (`period == 1`).

**Dicas:** Lembre-se da aula de `dplyr`! √â poss√≠vel resolver esse exerc√≠cio
com apenas uma pipeline (na qual precisa haver apenas um `mutate()`). Entenda
a fun√ß√£o `ms()` (ela n√£o √© o que parece).

???

lakers %&gt;% 
  dplyr::filter(etype == "shot", period == 1, team == "LAL") %&gt;% 
  dplyr::mutate(time = as.duration(ms(time))) %&gt;%
  dplyr::group_by(date) %&gt;%
  dplyr::summarise(first = min(time)) %&gt;%
  dplyr::pull(first) %&gt;%
  mean()



---
class: center, middle, inverse

# OBRIGADO!
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
